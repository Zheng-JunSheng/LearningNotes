# BM Sunday算法优劣评估

## 1.简介

在字符串匹配时，用到了BM算法和Sunday算法，在此分析一下两种算法的优劣。

## 2.BM

### 2.1算法思想

​	在KMP算法当中，我们采用文本串S和模式串P从前向后进行比较的方式进行字符串匹配。而BM算法则是使用以模式串P为标准的，从后向前进行匹配的方式进行字符串匹配操作，即当文本串S与模式串P左端对齐之后，我们从模式串P的最右侧开始，逐个字符的向前与文本串S进行比较和匹配。而BM算法从后向前的比较方式，依赖于其中**坏字符**与**好后缀**两个概念。

​	坏字符：当模式串P与文本串S进行从后向前进行比较的过程中，第一个遇见失配的字符，即为坏字符；

​	好后缀：当模式串P与文本串S进行从后向前进行比较的过程中，在遇见坏字符之前，能够相互匹配的多个字符构成的子串以及这些子串的子串，都称之为好后缀。

BM算法是每次向右移动模式串的距离是，按照好后缀算法和坏字符算法计算得到的最大值。

### 2.2时间复杂度分析

​	我们假设文本串S的长度为n，模式串P的长度为m，且m <= n。

​    在最理想情况下，假设模式串的长度等于文本串的长度，并且模式串在最开始的情况下就能够直接匹配上整个的文本串，此时BM算法的时间复杂度等同于遍历整个文本串的时间复杂度，所以BM算法的最好时间复杂度为O(n)。

 	在最坏情况下，我们假设每一次模式串与文本串的比较过程中，都只在最后一个字符比较的时候，也就是模式串中下标为0的字符比较的时候出现坏字符的情况，并且坏字符每次都出现在模式串中，而且通过坏字符对齐进行的比较，每一次又都无法匹配整个模式串，所以BM算法的最坏时间复杂度是O(n*m）。
 	
 	在平均情况下，在每一次文本串S与模式串P失配的情况下，也就是出现坏字符的情况下，我们都假设坏字符并没有出现的模式串P中。那么我们就可以认为：每次失配的情况，都会导致模式串P向后移动m位，也就是将模式串P与坏字符之后的一个字符对齐的情况。并且我们假设，如果出现模式串P与文本串S相匹配的情况，就一定是模式串P完全匹配的情况，也就是在文本串S中找到模式串P的情况。此种情况下，我们不需要再去移动模式串P。

​	模式串P在文本串S中移动的次数为n/m次，每一次移动导致一次单个字符的比较，再加上最后一次匹配情况的发生，比较的次数为m次，算法整体的比较次数为n/m+m次。所以BM算法平均复杂度为O(n/m).

## 3.sunday算法

### 3.1算法思想

​	Sunday算法实际上是一种对BM算法的改进，其基本思路与BM算法相似。但是与BM算法不同的是，Sunday算法是从前往后匹配，在匹配失败时关注的是主串中参加匹配的最末位字符的下一位字符。

1. ​	如果该字符没有在模式串中出现则直接跳过，即移动位数 = 模式串长度 + 1；
2. ​	否则，其移动位数 = 模式串长度 - 该字符最右出现的位置(以0开始) = 模式串中该字符最右出现的位置到尾部的距离 + 1。

### 3.2时间复杂度分析

Sunday算法因为是在BM算法的基础上进行改进的，所以其理论时间复杂程度与BM算法是相似的，即：最好时间复杂度为O(n)，最坏时间复杂度为O(n*m)，平均时间复杂度为O(n/m)。

## 3.总结

BM会将搜索所需的比较次数减少到绝对必要的最小值的近似值。最大的问题是，这样做需要更多的预处理（和更多的内存）。但Sunday算法在一般情况下有着比BM算法更大的跳跃距离，所以要根据实际情况考虑使用哪种算法。





